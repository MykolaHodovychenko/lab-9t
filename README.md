# Лабораторна робота 9. Колекції в Java. Списки та черги.

## Цілі лабораторної роботи:

## Цели лабораторной работы

- визначити призначення колекцій та сценарії їх використання;
- вивчити призначення інтерфейсу `List` та особливості реалізації цього інтерфейсу;
- вивчити призначення інтерфейсу `Queue` та `Deque`, а також особливості реалізації цього інтерфейсу.

## Хід роботи

### Завдання 1

Реалізуйте метод `removeShorterStrings()`, який приймає `List<String>` і видаляє з кожної пари рядків, рядок з меншою довжиною.

Наприклад, для списку:

`{"four", "score", "and", "seven", "years", "ago"}`

перелік пар буде таким:

- `{"four", "score"}`
- `{"and", "seven"}`
- `{"years", "ago"}`

Метод повинен знайти рядок з меншою довжиною з кожної пари рядків та видалити його. В результаті, метод повинен змінити список наступним чином:

`{"score", "seven", "years"}`

Якщо рядки в парі будуть однакової довжини, метод повинен видалити перший рядок з пари.

Якщо список буде мати непарну кількість елементів, метод повинен залишити останній елемент без змін.

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 2

Реалізуйте метод `stutter()`, який приймає `List<String>` та дублює кожен рядок у списку.

Наприклад, якщо метод приймає на вхід список:

`{"how", "are", "you?"}`

то вхідний рядок повинен бути змінений наступним чином:

`{"how", "how", "are", "are", "you?", "you?"}`

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 3

Реалізуйте метод `switchPairs()`, який приймає `List<String>` та попарно змінює елементи місцями.

Наприклад, для списку:

`{"four", "score", "and", "seven", "years", "ago"}`

перелік пар буде:

- `{"four", "score"}`
- `{"and", "seven"}`
- `{"years", "ago"}`

Метод повинен змінювати елементи місцями в кожній парі чисел. В результаті метод повинен перетворити список наступним чином:

`{"score", "four", "seven", "and", "ago", "years"}`

Якщо список буде містити непарну кількість елементів, метод повинен залишити останній елемент списку без змін.

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 4

Реалізуйте метод `removeDuplicates()`, який приймає `List<String>` та видаляє із списку дублікати (**рядки у списку будуть відсортовані**).

Припустимо, є такий вхідний список:

`{"be", "be", "is", "not", "or", "question", "that", "the", "to", "to"}`

Метод повинен перетворити список наступним чином:

`{"be", "is", "not", "or", "question", "that", "the", "to"}`

Так як список буде відсортований, то дублікати будуть згруповані разом.

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 5

Реалізуйте метод `markLength4()`, який приймає `List<String>` та додає рядок `****` перед кожним рядок із 4 символів.

Припустимо, є вхідний рядок:

`{"this", "is", "lots", "of", "fun", "for", "every", "Java", "programmer"}`

Метод повинен перетворити рядок наступним чином:

`{"****", "this", "is", "****", "lots", "of", "fun", "for", "every", "****", "Java", "programmer"}`

Зверніть увагу на те, що оригінальні рядки з 4 символів не змінюються та не видаляються, а залишаються у списку. Рядок `****` додається перед рядком з 4 символів, а не замінює його.

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 6

Напишіть метод `isPalindrome()`, який приймає в якості вхідного параметру `Queue<Integer>` та повертає `true`, якщо числа в черзі представляють собою паліндром (та `false` у іншому випадку). Послідовність чисел вважається паліндромом, якщо вона однакова у прямому та зворотньому порядку.

Наприклад, припустимо, що є черга `q`, яка зберігає такі дані:

front `[3, 8, 17, 9, 17, 8, 3]` back

Виклик методу `isPalindrome(q)` повинен повернути `true`, тому що ця послідовність однакова у прямому та зворотньому порядку. Якщо б черга зберігала такі значення:

front `[3, 8, 17, 9, 4, 17, 8, 3]` back

Виклик методу `isPalindrome()` замість цього поверне `false`, тому що ця послідовність не збігається у зворотньому порядку (9 та 4 у середині не збігаються).

Пусту чергу слід вважати паліндромом.

Ви не повинні робити ніяких припущень стосовно того, скільки елементів знаходиться у черзі. Ви можете використати один екземпляр `ArrayDeque<Integer>` у якості допоміжного стеку для вирішення цієї задачі.

**Додаткове завдання** Реалізуйте метод таким чином, щоб вхідна черга за результатами роботи методу залишилась в тому ж вигляді, в якому вона була на початку роботи методу.

### Завдання 7

Реалізуйте метод `reorder()`, який приймає `Queue<Integer>` у якості параметру. Вхідна черга відсортована за зростанням **абсолютного значення** числа. Приклад такої черги:

front `[1, 2, -2, 4, -5, 8, -8, 12, -15, 23]` back

Метод `reorder()` повинен **змінити вхідну чергу** (метод не повинен створювати нові черги та повинен повертати `void`), щоб вона була відсортована за зростанням з урахуванням знаку числа.

Для прикладу вище, метод `reorder()` повинен змінити значення місцями таким чином, щоб черга мала наступний вигляд:

front `[-15, -8, -5, -2, 1, 2, 4, 8, 12, 23]` back

Ви можете використати один екземпляр `ArrayDeque<Integer>` у якості допоміжного стеку для вирішення цієї задачі.

### Завдання 8

Реалізуйте метод `rearrange()`, який приймає на вхід `Queue<Integer>` у якості параметру та змінює порядок значень таким чином, щоб всі парні значення з'являлись перед непарними значеннями, зберігаючи порядок слідування парних та непарних значень між собою.

Наприклад, припустимо, що черга `q` зберігає таку послідовність значень:

front `[3, 5, 4, 17, 6, 83, 1, 84, 16, 37]` back

Виклик методу `rearrange(q)` повинен змінити порядок елементів черги наступним чином:

front `[4, 6, 84, 16, 3, 5, 17, 83, 1, 37]` back

Зверніть увагу, що всі парні числа з'являються на початку черги, за якими йдуть непарні, та порядок парних чисел є таким ж, як у вихідній черзі, че ж стосується і непарних чисел.

Ви можете використати один екземпляр `ArrayDeque<Integer>` у якості допоміжного стеку для вирішення цієї задачі.
